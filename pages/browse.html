<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Browse All Resources - Academic Resort</title>
    <link rel="preconnect" href="https://www.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../assets/styles.css" />
    <script src="../assets/script.js" defer></script>
  </head>
  <body>
    <div data-include="../assets/includes/sidebar.html"></div>
    <header class="app-header"><h1>Academic Resort</h1></header>
    <main class="container">
      <div style="margin-bottom: 24px">
        <h1
          style="
            text-align: center;
            margin: 48px 0;
            font-size: 2.5rem;
            font-weight: 600;
          "
        >
          Browse All Resources
        </h1>
        <p>
          <b
            >Search and filter through all academic resources across all
            semesters and batches.</b
          >
        </p>
      </div>

      <!-- Advanced Search/Filter -->
      <div class="search-panel">
        <div class="search-row">
          <input
            type="text"
            id="globalSearch"
            placeholder="Search something..."
            oninput="debounce(optimizedSearch, 500)()"
          />
        </div>

        <div class="filter-row">
          <select id="semesterFilter" onchange="optimizedSearch()">
            <option value="">All Semesters</option>
            <option value="1st">1st Semester</option>
            <option value="2nd">2nd Semester</option>
            <option value="3rd">3rd Semester</option>
            <option value="4th">4th Semester</option>
            <option value="5th">5th Semester</option>
            <option value="6th">6th Semester</option>
            <option value="7th">7th Semester</option>
            <option value="8th">8th Semester</option>
          </select>

          <select id="batchFilter" onchange="optimizedSearch()">
            <option value="">All Batches</option>
            <option value="30">30th Batch</option>
            <option value="29">29th Batch</option>
            <option value="28">28th Batch</option>
            <option value="27">27th Batch</option>
            <option value="26">26th Batch</option>
          </select>
        </div>
      </div>

      <!-- Results Container -->
      <div id="results-container">
        <div class="results-header">
          <div class="results-stats" id="resultsStats">
            Loading resources...
          </div>

          <!-- Accordion Controls -->
          <div
            class="accordion-controls"
            id="accordionControls"
            style="display: none"
          >
            <button
              class="control-btn"
              onclick="expandAllSemesters()"
              title="Expand all semesters"
            >
              üìÇ Expand All
            </button>
            <button
              class="control-btn"
              onclick="collapseAllSemesters()"
              title="Collapse all semesters"
            >
              üìÅ Collapse All
            </button>
            <button
              class="control-btn"
              onclick="collapseAllBatches()"
              title="Collapse all batches"
            >
              üóÇÔ∏è Minimize Batches
            </button>
          </div>
        </div>

        <!-- All Drive Resources will be loaded here -->
        <div id="all-resources"></div>
      </div>
    </main>

    <div data-include="../assets/includes/footer.html"></div>

    <script>
      // API key restricted to jabir-a-h.github.io domain in Google Cloud Console
      const DRIVE_API_KEY = "AIzaSyAEOadL6D0G_c8z5EB-sEp0T3hanYAnmF0";
      let ALL_DRIVE_RESOURCES = {}; // Will be loaded from JSON
      let allFiles = []; // Store all loaded files for searching
      let isLoading = false;
      let fileCache = new Map(); // Cache for API responses
      let loadedFolders = new Set(); // Track which folders we've already loaded

      // === PERSISTENT CACHE SYSTEM (24-hour localStorage) ===

      // Cache configuration
      const CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
      const CACHE_VERSION = "v1"; // Increment this to force cache refresh on updates

      // === RATE LIMITING SYSTEM ===

      class APIRateLimiter {
        constructor(maxConcurrent = 3, delayBetween = 100) {
          this.maxConcurrent = maxConcurrent;
          this.delayBetween = delayBetween;
          this.activeRequests = 0;
          this.requestQueue = [];
          this.isProcessing = false;
        }

        async makeRequest(url) {
          return new Promise((resolve, reject) => {
            this.requestQueue.push({ url, resolve, reject });
            this.processQueue();
          });
        }

        async processQueue() {
          if (this.isProcessing || this.requestQueue.length === 0) return;

          this.isProcessing = true;

          while (
            this.requestQueue.length > 0 &&
            this.activeRequests < this.maxConcurrent
          ) {
            const { url, resolve, reject } = this.requestQueue.shift();
            this.activeRequests++;

            this.executeRequest(url, resolve, reject);

            // Small delay between starting requests
            if (this.requestQueue.length > 0) {
              await new Promise((resolve) =>
                setTimeout(resolve, this.delayBetween)
              );
            }
          }

          this.isProcessing = false;
        }

        async executeRequest(url, resolve, reject) {
          try {
            const response = await fetch(url);

            if (!response.ok) {
              throw new Error(
                `API Error: ${response.status} - ${response.statusText}`
              );
            }

            const data = await response.json();
            resolve(data);
          } catch (error) {
            reject(error);
          } finally {
            // Always decrement counter, whether success or error
            this.activeRequests = Math.max(0, this.activeRequests - 1);

            // Continue processing queue
            setTimeout(() => this.processQueue(), this.delayBetween);
          }
        }

        getStats() {
          return {
            activeRequests: this.activeRequests,
            queueLength: this.requestQueue.length,
            maxConcurrent: this.maxConcurrent,
          };
        }
      }

      // Create global rate limiter instance (HYPER-AGGRESSIVE for maximum speed)
      const apiLimiter = new APIRateLimiter(100, 5); // Max 100 concurrent, 5ms between starts

      // Get cache key for a folder
      function getCacheKey(folderId, currentDepth) {
        return `driveCache_${CACHE_VERSION}_${folderId}_${currentDepth}`;
      }

      // Get global cache metadata key
      function getGlobalCacheKey() {
        return `driveCacheMetadata_${CACHE_VERSION}`;
      }

      // Save data to persistent cache with timestamp
      function saveToPersistentCache(folderId, currentDepth, data) {
        try {
          const cacheKey = getCacheKey(folderId, currentDepth);
          const cacheData = {
            data: data,
            timestamp: Date.now(),
            version: CACHE_VERSION,
          };
          localStorage.setItem(cacheKey, JSON.stringify(cacheData));

          // Update metadata
          updateCacheMetadata(cacheKey);
        } catch (error) {
          console.warn("Failed to save to persistent cache:", error);
        }
      }

      // Load data from persistent cache
      function loadFromPersistentCache(folderId, currentDepth) {
        try {
          const cacheKey = getCacheKey(folderId, currentDepth);
          const cached = localStorage.getItem(cacheKey);

          if (!cached) return null;

          const cacheData = JSON.parse(cached);
          const age = Date.now() - cacheData.timestamp;

          // Check if cache is expired or version mismatch
          if (age > CACHE_DURATION || cacheData.version !== CACHE_VERSION) {
            localStorage.removeItem(cacheKey);
            removeCacheFromMetadata(cacheKey);
            return null;
          }

          return cacheData.data;
        } catch (error) {
          console.warn("Failed to load from persistent cache:", error);
          return null;
        }
      }

      // Update cache metadata for cleanup
      function updateCacheMetadata(cacheKey) {
        try {
          const metaKey = getGlobalCacheKey();
          let metadata = JSON.parse(
            localStorage.getItem(metaKey) || '{"keys":[],"lastCleanup":0}'
          );

          if (!metadata.keys.includes(cacheKey)) {
            metadata.keys.push(cacheKey);
          }
          metadata.lastUpdated = Date.now();

          localStorage.setItem(metaKey, JSON.stringify(metadata));
        } catch (error) {
          console.warn("Failed to update cache metadata:", error);
        }
      }

      // Remove cache key from metadata
      function removeCacheFromMetadata(cacheKey) {
        try {
          const metaKey = getGlobalCacheKey();
          let metadata = JSON.parse(
            localStorage.getItem(metaKey) || '{"keys":[],"lastCleanup":0}'
          );
          metadata.keys = metadata.keys.filter((key) => key !== cacheKey);
          localStorage.setItem(metaKey, JSON.stringify(metadata));
        } catch (error) {
          console.warn("Failed to remove from cache metadata:", error);
        }
      }

      // Clean expired cache entries
      function cleanExpiredCache() {
        try {
          const metaKey = getGlobalCacheKey();
          let metadata = JSON.parse(
            localStorage.getItem(metaKey) || '{"keys":[],"lastCleanup":0}'
          );

          // Only run cleanup once per hour
          if (Date.now() - metadata.lastCleanup < 60 * 60 * 1000) return;

          const validKeys = [];

          metadata.keys.forEach((cacheKey) => {
            try {
              const cached = localStorage.getItem(cacheKey);
              if (cached) {
                const cacheData = JSON.parse(cached);
                const age = Date.now() - cacheData.timestamp;

                if (
                  age <= CACHE_DURATION &&
                  cacheData.version === CACHE_VERSION
                ) {
                  validKeys.push(cacheKey);
                } else {
                  localStorage.removeItem(cacheKey);
                }
              }
            } catch (error) {
              // Remove invalid cache entries
              localStorage.removeItem(cacheKey);
            }
          });

          metadata.keys = validKeys;
          metadata.lastCleanup = Date.now();
          localStorage.setItem(metaKey, JSON.stringify(metadata));
        } catch (error) {
          console.warn("Cache cleanup failed:", error);
        }
      }

      // Get cache statistics
      function getCacheStats() {
        try {
          const metaKey = getGlobalCacheKey();
          const metadata = JSON.parse(
            localStorage.getItem(metaKey) || '{"keys":[],"lastCleanup":0}'
          );

          let totalSize = 0;
          let validEntries = 0;

          metadata.keys.forEach((cacheKey) => {
            const cached = localStorage.getItem(cacheKey);
            if (cached) {
              totalSize += cached.length;
              validEntries++;
            }
          });

          return {
            entries: validEntries,
            sizeKB: Math.round(totalSize / 1024),
            lastUpdated: metadata.lastUpdated
              ? new Date(metadata.lastUpdated).toLocaleString()
              : "Never",
          };
        } catch (error) {
          return { entries: 0, sizeKB: 0, lastUpdated: "Error" };
        }
      }

      // === CACHE MANAGEMENT FUNCTIONS ===

      // Clear all cache data (useful for debugging or forcing refresh)
      function clearAllCache() {
        try {
          const metaKey = getGlobalCacheKey();
          const metadata = JSON.parse(
            localStorage.getItem(metaKey) || '{"keys":[],"lastCleanup":0}'
          );

          // Remove all cache entries
          metadata.keys.forEach((cacheKey) => {
            localStorage.removeItem(cacheKey);
          });

          // Clear metadata
          localStorage.removeItem(metaKey);

          // Clear in-memory cache
          fileCache.clear();

          console.log("üóëÔ∏è All cache data cleared");
          return true;
        } catch (error) {
          console.error("Failed to clear cache:", error);
          return false;
        }
      }

      // Clear cache and start immediate rebuild (for UI link)
      function clearCacheAndReload() {
        if (
          confirm(
            "Clear all cached data and rebuild? Since you're already on the search page, rebuilding will be faster!"
          )
        ) {
          clearAllCache();

          // Update status to show rebuilding
          const stats = document.getElementById("resultsStats");
          stats.textContent =
            "üîÑ Cache cleared! Rebuilding cache with priority speed...";

          // Start immediate foreground rebuilding (faster since user is engaged)
          if (
            window.backgroundCachePreloader &&
            window.backgroundCachePreloader.instance()
          ) {
            const preloader = window.backgroundCachePreloader.instance();
            preloader.stopPreloading(); // Stop background preloader

            // Start faster rebuild for immediate use
            setTimeout(() => {
              startImmediateRebuild(stats);
            }, 500);
          } else {
            // Fallback to page reload if background preloader not available
            location.reload();
          }
        }
      }

      // Fast cache rebuild when user is actively on browse page
      async function startImmediateRebuild(statusElement) {
        statusElement.textContent = "üöÄ Fast rebuilding cache...";

        try {
          // Use foreground rate limiter for faster rebuilding
          await loadDriveMapping();

          const driveMapping = ALL_DRIVE_RESOURCES;
          const folderList = Object.entries(driveMapping).flatMap(
            ([semester, batches]) =>
              Object.entries(batches).map(([batchKey, batchInfo]) => ({
                folderId: batchInfo.folderId,
                label: batchInfo.label,
                semester,
                batchKey,
              }))
          );

          let completed = 0;

          for (const folder of folderList) {
            completed++;
            statusElement.textContent = `üîÑ Rebuilding cache: ${completed}/${
              folderList.length
            } folders (${Math.round((completed / folderList.length) * 100)}%)`;

            try {
              await rebuildFolderCache(folder.folderId, 0, 4);
            } catch (error) {
              console.warn(`Failed to rebuild ${folder.label}:`, error);
            }
          }

          // Get fresh cache stats
          const cacheStats = getCacheStats();
          statusElement.innerHTML = `‚úÖ Ready! ${cacheStats.entries} folders available. Enter search terms to find resources. <a href="#" onclick="clearCacheAndReload()" style="color: #6b7280; font-size: 0.85em; text-decoration: none; margin-left: 8px;" title="Clear cache and reload fresh data">‚ü≥</a>`;

          console.log("‚úÖ Fast cache rebuild completed!");
        } catch (error) {
          statusElement.textContent =
            "‚ùå Rebuild failed. Please refresh the page.";
          console.error("Cache rebuild error:", error);
        }
      }

      // Fast folder cache rebuild (uses foreground rate limiter)
      async function rebuildFolderCache(folderId, currentDepth, maxDepth) {
        if (currentDepth >= maxDepth) return;

        const url = `https://www.googleapis.com/drive/v3/files?q='${folderId}'+in+parents+and+trashed=false&key=${DRIVE_API_KEY}&fields=files(id,name,mimeType,webViewLink)&pageSize=1000&orderBy=name`;

        try {
          const data = await apiLimiter.makeRequest(url); // Use foreground limiter for speed

          // Save to cache
          saveToPersistentCache(folderId, currentDepth, data.files || []);

          // Rebuild subfolders
          const folders = (data.files || []).filter(
            (file) => file.mimeType === "application/vnd.google-apps.folder"
          );

          for (const folder of folders) {
            await rebuildFolderCache(folder.id, currentDepth + 1, maxDepth);
          }
        } catch (error) {
          console.warn(`Rebuild failed for folder ${folderId}:`, error);
        }
      }

      // Make cache management functions available globally for debugging
      window.cacheManagement = {
        stats: getCacheStats,
        clear: clearAllCache,
        cleanup: cleanExpiredCache,
      };

      // === END CACHE SYSTEM ===

      // Optimized search - only load data when user searches (like Google Drive)
      async function optimizedSearch() {
        const searchTerm = document
          .getElementById("globalSearch")
          .value.toLowerCase()
          .trim();
        const semesterFilter = document.getElementById("semesterFilter").value;
        const batchFilter = document.getElementById("batchFilter").value;
        const stats = document.getElementById("resultsStats");

        if (!searchTerm && !semesterFilter && !batchFilter) {
          displayResults([]);
          stats.textContent =
            "Enter a search term or select filters to find resources.";
          return;
        }

        if (searchTerm && searchTerm.length < 2) {
          stats.textContent = "Type at least 2 characters to search...";
          return;
        }

        stats.textContent = "üîç Searching...";

        // Add timeout for maximum 45 seconds (better than 12 minutes!)
        const searchPromise = smartSearch(
          searchTerm,
          semesterFilter,
          batchFilter,
          stats
        );
        const timeoutPromise = new Promise((_, reject) =>
          setTimeout(
            () =>
              reject(new Error("Search timeout - results may be incomplete")),
            45000
          )
        );

        try {
          const results = await Promise.race([searchPromise, timeoutPromise]);
          displayResults(results);
          updateStats(results.length, "‚àû", ` (search results)`);
          stats.innerHTML = `‚úÖ Found ${results.length} results`;
        } catch (error) {
          if (error.message.includes("timeout")) {
            stats.textContent = `‚ö†Ô∏è Search timed out - try more specific terms`;
          } else {
            console.error("Search error:", error);
            stats.textContent = "‚ùå Search failed. Please try again.";
          }
        }
      }

      // Smart search that searches all nested folders recursively (with rate limiting)
      async function smartSearch(
        searchTerm,
        semesterFilter,
        batchFilter,
        statsElement
      ) {
        const results = [];

        // Smart folder organization: Group by semester, then distribute evenly
        const semesterBatches = {};
        for (const [semester, batches] of Object.entries(ALL_DRIVE_RESOURCES)) {
          if (semesterFilter && semester !== semesterFilter) continue;
          semesterBatches[semester] = [];
          for (const [batchKey, batchInfo] of Object.entries(batches)) {
            if (batchFilter && batchKey !== batchFilter) continue;
            semesterBatches[semester].push({
              semester,
              batchKey,
              batchInfo,
            });
          }
        }

        // Create round-robin batches: 1st from each semester, then 2nd from each, etc.
        const smartBatches = [];
        const maxBatchesPerSemester = Math.max(
          ...Object.values(semesterBatches).map((batches) => batches.length)
        );

        for (
          let batchIndex = 0;
          batchIndex < maxBatchesPerSemester;
          batchIndex++
        ) {
          const roundRobinBatch = [];
          for (const semester of Object.keys(semesterBatches)) {
            if (semesterBatches[semester][batchIndex]) {
              roundRobinBatch.push(semesterBatches[semester][batchIndex]);
            }
          }
          if (roundRobinBatch.length > 0) {
            smartBatches.push(roundRobinBatch);
          }
        }

        // Search folders in parallel batches - 30 folders simultaneously for MAXIMUM speed
        const PARALLEL_BATCH_SIZE = 30; // Process 30 folders simultaneously (hyper-aggressive)
        const MAX_SEARCH_DEPTH = 4; // Depth of 4 levels for comprehensive nested file discovery

        // Clear results container at start
        const container = document.getElementById("all-resources");
        container.innerHTML =
          '<div class="live-results" style="color: #a0aec0; font-size: 0.9em; text-align: center; padding: 20px;">Searching...</div>';

        let totalFolders = 0;
        let completedFolders = 0;

        // Count total folders
        smartBatches.forEach((batch) => (totalFolders += batch.length));

        // Process each round-robin batch
        for (const roundRobinBatch of smartBatches) {
          // Split into parallel batches of 20 for maximum speed
          for (
            let i = 0;
            i < roundRobinBatch.length;
            i += PARALLEL_BATCH_SIZE
          ) {
            const batch = roundRobinBatch.slice(i, i + PARALLEL_BATCH_SIZE);

            // Process this batch of folders in parallel
            const batchPromises = batch.map(
              async ({ semester, batchKey, batchInfo }) => {
                try {
                  // Search with LIMITED depth for speed (most files are within 3 levels)
                  const folderResults = await searchInFolderRecursive(
                    batchInfo.folderId,
                    "",
                    MAX_SEARCH_DEPTH, // Limited to 3 levels for speed
                    searchTerm,
                    semester,
                    batchKey,
                    batchInfo.label,
                    statsElement
                  );
                  return folderResults;
                } catch (error) {
                  console.warn(`Failed to search ${batchInfo.label}:`, error);
                  return [];
                }
              }
            );

            // Wait for this batch to complete
            const batchResults = await Promise.all(batchPromises);

            // Add results and update progress
            for (const folderResults of batchResults) {
              results.push(...folderResults);
            }

            completedFolders += batch.length;
            const limiterStats = apiLimiter.getStats();

            // Update results display in real-time after each batch
            const currentResults = removeDuplicatesOptimized(results);
            if (currentResults.length > 0) {
              displayResults(currentResults);
              // Update stats with results count on the right
              statsElement.innerHTML = `ÔøΩ Speed-searched ${completedFolders}/${totalFolders} folders | Queue: ${limiterStats.queueLength} | Active: ${limiterStats.activeRequests} <span style="float: right; color: #68d391; font-size: 0.9em;">${currentResults.length} results</span>`;
            } else {
              statsElement.textContent = `ÔøΩ Speed-searched ${completedFolders}/${totalFolders} folders | Queue: ${limiterStats.queueLength} | Active: ${limiterStats.activeRequests}`;
            }

            // Early termination if we have many results
            if (currentResults.length > 300) {
              statsElement.innerHTML = `‚úÖ Found ${currentResults.length} results <span style="float: right; color: #68d391; font-size: 0.9em;">${currentResults.length} results</span>`;
              return removeDuplicatesOptimized(results);
            }

            // Also stop early if search term is very specific and we found good matches
            if (
              searchTerm &&
              searchTerm.length > 8 &&
              currentResults.length > 50
            ) {
              statsElement.innerHTML = `‚úÖ Found ${currentResults.length} results <span style="float: right; color: #68d391; font-size: 0.9em;">${currentResults.length} results</span>`;
              return removeDuplicatesOptimized(results);
            }
          }
        }

        const flatResults = removeDuplicatesOptimized(results);

        // Final update - show completion in stats line
        statsElement.innerHTML = `‚úÖ Search complete <span style="float: right; color: #68d391; font-size: 0.9em;">${flatResults.length} results</span>`;

        // Log rate limiter performance (easter egg for developers)
        const finalStats = apiLimiter.getStats();
        console.log("üöÄ Search completed! Rate limiter stats:", finalStats);

        return flatResults;
      }

      // Advanced search matching like Google - prioritizes exact phrases and complete words
      function smartMatch(searchTerm, fileName, filePath) {
        const search = searchTerm.toLowerCase().trim();
        const name = fileName.toLowerCase();
        const path = filePath.toLowerCase();

        // If search is empty, don't match anything
        if (!search) return false;

        // 1. EXACT PHRASE MATCH (highest priority) - like Google's quoted search
        if (name.includes(search) || path.includes(search)) {
          return true;
        }

        // 2. COMPLETE WORD BOUNDARIES - avoid partial word matches
        // Split search into individual words
        const searchWords = search
          .split(/\s+/)
          .filter((word) => word.length > 0);

        // For single word searches, use word boundaries to avoid partial matches
        if (searchWords.length === 1) {
          const word = searchWords[0];
          // Create regex with word boundaries (\b) to match complete words only
          const wordBoundaryRegex = new RegExp(
            `\\b${word.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}\\b`,
            "i"
          );
          return wordBoundaryRegex.test(name) || wordBoundaryRegex.test(path);
        }

        // 3. ALL WORDS MUST BE PRESENT (like Google's AND logic)
        // Each word must be found as a complete word, not partial
        const allWordsPresent = searchWords.every((word) => {
          const wordBoundaryRegex = new RegExp(
            `\\b${word.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}\\b`,
            "i"
          );
          return wordBoundaryRegex.test(name) || wordBoundaryRegex.test(path);
        });

        if (allWordsPresent) {
          return true;
        }

        // 4. FLEXIBLE SPACING - remove spaces and check (for compound words)
        const searchNoSpaces = search.replace(/\s+/g, "");
        const nameNoSpaces = name.replace(/\s+/g, "");
        const pathNoSpaces = path.replace(/\s+/g, "");

        if (
          nameNoSpaces.includes(searchNoSpaces) ||
          pathNoSpaces.includes(searchNoSpaces)
        ) {
          return true;
        }

        // 5. ACRONYM MATCHING (only for 3+ character searches)
        if (search.length >= 3 && !search.includes(" ")) {
          const nameWords = name
            .split(/[\s\-_\.]+/)
            .filter((w) => w.length > 0);
          const pathWords = path
            .split(/[\s\-_\.\/]+/)
            .filter((w) => w.length > 0);

          const nameAcronym = nameWords.map((word) => word.charAt(0)).join("");
          const pathAcronym = pathWords.map((word) => word.charAt(0)).join("");

          if (nameAcronym.includes(search) || pathAcronym.includes(search)) {
            return true;
          }
        }

        return false;
        const similarInName = nameWords.some(
          (word) =>
            word.length >= 3 &&
            levenshteinDistance(searchWord, word) <=
              Math.floor(searchWord.length * 0.3)
        );
        const similarInPath = pathWords.some(
          (word) =>
            word.length >= 3 &&
            levenshteinDistance(searchWord, word) <=
              Math.floor(searchWord.length * 0.3)
        );
      }

      // Calculate Levenshtein distance for fuzzy matching
      function levenshteinDistance(str1, str2) {
        const matrix = [];

        for (let i = 0; i <= str2.length; i++) {
          matrix[i] = [i];
        }

        for (let j = 0; j <= str1.length; j++) {
          matrix[0][j] = j;
        }

        for (let i = 1; i <= str2.length; i++) {
          for (let j = 1; j <= str1.length; j++) {
            if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
              matrix[i][j] = matrix[i - 1][j - 1];
            } else {
              matrix[i][j] = Math.min(
                matrix[i - 1][j - 1] + 1, // substitution
                matrix[i][j - 1] + 1, // insertion
                matrix[i - 1][j] + 1 // deletion
              );
            }
          }
        }

        return matrix[str2.length][str1.length];
      }

      // Normalize text for flexible matching
      function normalizeText(text) {
        return text
          .toLowerCase()
          .replace(/[^\w\s]/g, "") // Remove special characters
          .replace(/\s+/g, "") // Remove spaces
          .replace(/(\d+)/g, (match) => match.padStart(3, "0")); // Normalize numbers
      }

      // Recursive folder search that searches all nested folders
      async function searchInFolderRecursive(
        folderId,
        path,
        maxDepth,
        searchTerm,
        semester,
        batchKey,
        batchLabel,
        statsElement,
        currentDepth = 0
      ) {
        // Check depth limit (-1 means unlimited depth)
        if (maxDepth >= 0 && currentDepth >= maxDepth) return [];

        // Check persistent cache first (24-hour localStorage)
        let cachedFiles = loadFromPersistentCache(folderId, currentDepth);

        if (cachedFiles) {
          // Update status to show cache hit
          if (statsElement && path) {
            statsElement.textContent = `‚úÖ Searching in ${path}...`;
          }

          // Also update in-memory cache
          const cacheKey = `${folderId}_${currentDepth}`;
          fileCache.set(cacheKey, cachedFiles);

          return await processFilesRecursively(
            cachedFiles,
            path,
            maxDepth,
            searchTerm,
            semester,
            batchKey,
            batchLabel,
            statsElement,
            currentDepth
          );
        }

        // Check in-memory cache second
        const cacheKey = `${folderId}_${currentDepth}`;
        if (fileCache.has(cacheKey)) {
          const memCachedFiles = fileCache.get(cacheKey);
          return await processFilesRecursively(
            memCachedFiles,
            path,
            maxDepth,
            searchTerm,
            semester,
            batchKey,
            batchLabel,
            statsElement,
            currentDepth
          );
        }

        try {
          // Update progress
          if (statsElement && path) {
            statsElement.textContent = `üîç Searching in ${path}...`;
          }

          // Rate-limited API call to prevent resource exhaustion - OPTIMIZED
          const url = `https://www.googleapis.com/drive/v3/files?q='${folderId}'+in+parents+and+trashed=false&key=${DRIVE_API_KEY}&fields=files(id,name,mimeType,webViewLink)&pageSize=1000&orderBy=name`;
          const data = await apiLimiter.makeRequest(url);

          // Cache the raw response in both memory and persistent storage
          const files = data.files || [];
          fileCache.set(cacheKey, files);
          saveToPersistentCache(folderId, currentDepth, files);

          return await processFilesRecursively(
            files,
            path,
            maxDepth,
            searchTerm,
            semester,
            batchKey,
            batchLabel,
            statsElement,
            currentDepth
          );
        } catch (error) {
          console.error(`Error searching folder ${folderId}:`, error);
          return [];
        }
      }

      // Process files and recursively search subfolders
      async function processFilesRecursively(
        files,
        path,
        maxDepth,
        searchTerm,
        semester,
        batchKey,
        batchLabel,
        statsElement,
        currentDepth
      ) {
        const results = [];
        const subfolderPromises = [];

        files.forEach((file) => {
          const filePath = path ? `${path}/${file.name}` : file.name;
          const isFolder =
            file.mimeType === "application/vnd.google-apps.folder";

          // Enhanced fuzzy search with multiple matching strategies
          const matchesSearch =
            !searchTerm || smartMatch(searchTerm, file.name, filePath);

          if (matchesSearch) {
            results.push({
              ...file,
              path: filePath,
              depth: currentDepth,
              isFolder: isFolder,
              semester: semester,
              batch: batchKey,
              batchLabel: batchLabel,
              parentPath: path,
            });
          }

          // If it's a folder, search it recursively (unlimited depth if maxDepth = -1)
          if (isFolder && (maxDepth < 0 || currentDepth < maxDepth - 1)) {
            subfolderPromises.push(
              searchInFolderRecursive(
                file.id,
                filePath,
                maxDepth,
                searchTerm,
                semester,
                batchKey,
                batchLabel,
                statsElement,
                currentDepth + 1
              )
            );
          }
        });

        // Wait for all subfolder searches to complete
        if (subfolderPromises.length > 0) {
          const subfolderResults = await Promise.all(subfolderPromises);
          results.push(...subfolderResults.flat());
        }

        return results;
      }

      // Optimized duplicate removal
      function removeDuplicatesOptimized(files) {
        const uniqueFiles = new Map();

        files.forEach((file) => {
          const key = `${file.id}_${file.path}`;
          if (!uniqueFiles.has(key)) {
            uniqueFiles.set(key, file);
          }
        });

        return Array.from(uniqueFiles.values()).sort((a, b) => {
          // Sort by relevance: exact matches first, then by depth, then alphabetically
          if (a.depth !== b.depth) return a.depth - b.depth;
          return a.name.localeCompare(b.name);
        });
      }

      // Progressive search by levels (1, 2, 3, 4)
      async function searchByLevels() {
        const searchTerm = document
          .getElementById("globalSearch")
          .value.toLowerCase()
          .trim();
        const semesterFilter = document.getElementById("semesterFilter").value;
        const batchFilter = document.getElementById("batchFilter").value;
        const stats = document.getElementById("resultsStats");
        const btn = document.getElementById("searchLevelBtn");

        if (!searchTerm && !semesterFilter && !batchFilter) {
          stats.textContent =
            "Please enter a search term or select filters first.";
          return;
        }

        if (searchTerm && searchTerm.length < 2) {
          stats.textContent = "Please enter at least 2 characters to search.";
          return;
        }

        // Disable button during search
        btn.disabled = true;
        btn.textContent = "Searching...";

        try {
          let allLevelResults = [];

          // Search through levels 1-4 progressively
          for (let level = 1; level <= 4; level++) {
            stats.textContent = `Searching level ${level} folders...`;

            const levelResults = await searchAtLevel(
              level,
              searchTerm,
              semesterFilter,
              batchFilter
            );
            allLevelResults = allLevelResults.concat(levelResults);

            // Show results progressively
            stats.textContent = `Found ${
              allLevelResults.length
            } results through level ${level}. ${
              level < 4 ? "Searching deeper..." : "Search complete!"
            }`;

            // Remove duplicates and display current results
            const uniqueResults = removeDuplicates(allLevelResults);
            displayResults(uniqueResults);
            updateStats(
              uniqueResults.length,
              allFiles.length,
              ` (through level ${level})`
            );

            // Small delay to show progress
            await new Promise((resolve) => setTimeout(resolve, 500));
          }

          stats.textContent = `Search complete! Found ${allLevelResults.length} results across all levels.`;
        } catch (error) {
          console.error("Error during level search:", error);
          stats.textContent = "Error occurred during search. Please try again.";
        } finally {
          // Re-enable button
          btn.disabled = false;
          btn.textContent = "üîç Search by Levels";
        }
      }

      // Search at a specific depth level
      async function searchAtLevel(
        targetLevel,
        searchTerm,
        semesterFilter,
        batchFilter
      ) {
        const levelResults = [];

        for (const [semester, batches] of Object.entries(ALL_DRIVE_RESOURCES)) {
          // Apply semester filter
          if (semesterFilter && semester !== semesterFilter) continue;

          for (const [batchKey, batchInfo] of Object.entries(batches)) {
            // Apply batch filter
            if (batchFilter && batchKey !== batchFilter) continue;

            try {
              const files = await fetchFilesAtDepth(
                batchInfo.folderId,
                "",
                targetLevel,
                0,
                semester,
                batchKey,
                batchInfo.label
              );

              // Filter results based on search term
              const matchingFiles = files.filter((file) => {
                return (
                  !searchTerm ||
                  file.name.toLowerCase().includes(searchTerm) ||
                  file.path.toLowerCase().includes(searchTerm) ||
                  batchInfo.label.toLowerCase().includes(searchTerm)
                );
              });

              levelResults.push(...matchingFiles);
            } catch (error) {
              console.error(
                `Error searching ${semester} - ${batchInfo.label} at level ${targetLevel}:`,
                error
              );
            }
          }
        }

        return levelResults;
      }

      // Fetch files at a specific depth level only - OPTIMIZED
      async function fetchFilesAtDepth(
        folderId,
        path = "",
        targetDepth = 1,
        currentDepth = 0,
        semester = "",
        batchKey = "",
        batchLabel = ""
      ) {
        if (currentDepth > targetDepth) return [];

        try {
          const response = await fetch(
            `https://www.googleapis.com/drive/v3/files?q='${folderId}'+in+parents+and+trashed=false&key=${DRIVE_API_KEY}&fields=files(id,name,mimeType,webViewLink)&pageSize=1000&orderBy=name`
          );

          if (!response.ok) {
            throw new Error(`API Error: ${response.status}`);
          }

          const data = await response.json();
          let results = [];

          if (data.files) {
            for (const file of data.files) {
              const filePath = path ? `${path}/${file.name}` : file.name;

              // If we're at the target depth, add this file to results
              if (currentDepth === targetDepth) {
                results.push({
                  ...file,
                  path: filePath,
                  depth: currentDepth,
                  isFolder:
                    file.mimeType === "application/vnd.google-apps.folder",
                  semester: semester,
                  batch: batchKey,
                  batchLabel: batchLabel,
                  parentPath: path,
                });
              }

              // If it's a folder and we haven't reached target depth, go deeper
              if (
                file.mimeType === "application/vnd.google-apps.folder" &&
                currentDepth < targetDepth
              ) {
                const subFiles = await fetchFilesAtDepth(
                  file.id,
                  filePath,
                  targetDepth,
                  currentDepth + 1,
                  semester,
                  batchKey,
                  batchLabel
                );
                results = results.concat(subFiles);
              }
            }
          }

          return results;
        } catch (error) {
          console.error(
            `Error fetching files at depth ${currentDepth}:`,
            error
          );
          return [];
        }
      }

      // Optimized duplicate removal for speed
      function removeDuplicatesOptimized(files) {
        if (files.length === 0) return [];

        const uniqueResults = new Map();

        // Use Map for O(1) lookups instead of array scanning
        files.forEach((file) => {
          const key = `${file.semester}_${file.batch}_${file.path}`;
          if (!uniqueResults.has(key)) {
            uniqueResults.set(key, file);
          }
        });

        return Array.from(uniqueResults.values());
      }

      // Remove duplicate files from search results (legacy fallback)
      function removeDuplicates(files) {
        return removeDuplicatesOptimized(files); // Use optimized version
      }

      // Recursively fetch all files from a folder with progress tracking - OPTIMIZED
      async function fetchAllFilesRecursively(
        folderId,
        path = "",
        maxDepth = 4, // Back to 4 levels for comprehensive nested discovery
        semester = "",
        batchLabel = "",
        statsElement = null,
        currentDepth = 0
      ) {
        if (currentDepth >= maxDepth) return [];

        try {
          const response = await fetch(
            `https://www.googleapis.com/drive/v3/files?q='${folderId}'+in+parents+and+trashed=false&key=${DRIVE_API_KEY}&fields=files(id,name,mimeType,webViewLink)&pageSize=1000&orderBy=name`
          );

          if (!response.ok) {
            throw new Error(`API Error: ${response.status}`);
          }

          const data = await response.json();
          let allFiles = [];

          if (data.files) {
            for (const file of data.files) {
              const filePath = path ? `${path}/${file.name}` : file.name;
              const fileData = {
                ...file,
                path: filePath,
                depth: currentDepth,
                isFolder:
                  file.mimeType === "application/vnd.google-apps.folder",
                parentPath: path,
              };

              allFiles.push(fileData);

              // Update progress for folders being processed
              if (
                statsElement &&
                file.mimeType === "application/vnd.google-apps.folder"
              ) {
                statsElement.textContent = `Scanning ${semester} - ${batchLabel} ‚Üí ${filePath}...`;
              }

              // If it's a folder, recursively fetch its contents
              if (file.mimeType === "application/vnd.google-apps.folder") {
                const subFiles = await fetchAllFilesRecursively(
                  file.id,
                  filePath,
                  maxDepth,
                  semester,
                  batchLabel,
                  statsElement,
                  currentDepth + 1
                );
                allFiles = allFiles.concat(subFiles);
              }
            }
          }

          return allFiles;
        } catch (error) {
          console.error(`Error fetching files from folder ${folderId}:`, error);
          return [];
        }
      }

      // Load mapping from JSON file
      async function loadDriveMapping() {
        try {
          const response = await fetch("../assets/drive-mapping.json");
          if (!response.ok)
            throw new Error(`Failed to load mapping: ${response.status}`);
          const mapping = await response.json();

          // Convert to the format expected by the rest of the code
          ALL_DRIVE_RESOURCES = {};
          Object.entries(mapping).forEach(([semester, semesterData]) => {
            ALL_DRIVE_RESOURCES[semester] = {};
            Object.entries(semesterData.batches).forEach(
              ([batchKey, batchData]) => {
                ALL_DRIVE_RESOURCES[semester][batchKey] = {
                  folderId: batchData.folderId,
                  label: batchData.label,
                };
              }
            );
          });

          return ALL_DRIVE_RESOURCES;
        } catch (error) {
          console.error("Error loading drive mapping:", error);
          // Fallback to basic structure if JSON fails
          ALL_DRIVE_RESOURCES = {
            "1st": {
              30: {
                folderId: "1ROStto-XpFTVfxyo9SLUL6Ou78pL6sat",
                label: "30th Batch",
              },
              29: {
                folderId: "1SV50Qd7OcbRsMd5tHzl0qXqW6BMdQ7uO",
                label: "29th Batch",
              },
            },
          };
          return ALL_DRIVE_RESOURCES;
        }
      }

      // Display search results with hierarchical tree structure
      function displayResults(files) {
        const container = document.getElementById("all-resources");
        const accordionControls = document.getElementById("accordionControls");
        container.innerHTML = "";

        if (files.length === 0) {
          container.innerHTML =
            '<div class="no-results">No files found. Use search to find specific files or folders.</div>';
          accordionControls.style.display = "none";
          return;
        }

        // Show accordion controls when there are results
        accordionControls.style.display = "flex";

        // Build hierarchical tree structure
        const treeStructure = buildTreeStructure(files);

        // Group by semester and batch
        const grouped = {};
        Object.entries(treeStructure).forEach(([key, tree]) => {
          const [semester, batch] = key.split("_");
          if (!grouped[semester]) grouped[semester] = {};
          grouped[semester][batch] = tree;
        });

        // Sort semesters (highest first: 8th, 7th, 6th, etc.)
        const sortedSemesters = Object.entries(grouped).sort(([a], [b]) => {
          const numA = parseInt(a.replace(/\D/g, "")) || 0;
          const numB = parseInt(b.replace(/\D/g, "")) || 0;
          return numB - numA;
        });

        sortedSemesters.forEach(([semester, batches]) => {
          const semesterDiv = document.createElement("div");
          semesterDiv.className = "semester-group";

          // Create collapsible semester header
          const semesterHeader = document.createElement("div");
          semesterHeader.className = "semester-header";
          semesterHeader.innerHTML = `
            <h2>
              <button class="accordion-btn" onclick="toggleSemesterCollapse('${semester}', this)">
                <span class="accordion-icon">‚ñº</span>
                ${semester.toUpperCase()} Semester
              </button>
            </h2>
          `;

          const semesterContent = document.createElement("div");
          semesterContent.className = "semester-content";
          semesterContent.id = `semester-${semester}`;

          // Sort batches (most recent first: 30th, 29th, 28th, etc.)
          const sortedBatches = Object.entries(batches).sort(([a], [b]) => {
            const numA = parseInt(a.replace(/\D/g, "")) || 0;
            const numB = parseInt(b.replace(/\D/g, "")) || 0;
            return numB - numA;
          });

          sortedBatches.forEach(([batch, tree]) => {
            const batchDiv = document.createElement("div");
            batchDiv.className = "batch-group";

            // Get batch label from any file in the tree
            const batchLabel = getBatchLabelFromTree(tree);

            // Create collapsible batch header
            const batchHeader = document.createElement("div");
            batchHeader.className = "batch-header";
            batchHeader.innerHTML = `
              <h3>
                <button class="accordion-btn" onclick="toggleBatchCollapse('${semester}', '${batch}', this)">
                  <span class="accordion-icon">‚ñº</span>
                  ${batchLabel}
                </button>
              </h3>
            `;

            const batchContent = document.createElement("div");
            batchContent.className = "batch-content";
            batchContent.id = `batch-${semester}-${batch}`;

            const resultsList = document.createElement("div");
            resultsList.className = "tree-results";

            // Render the tree structure
            renderTreeNode(tree, resultsList, 0);

            batchContent.appendChild(resultsList);
            batchDiv.appendChild(batchHeader);
            batchDiv.appendChild(batchContent);
            semesterContent.appendChild(batchDiv);
          });

          semesterDiv.appendChild(semesterHeader);
          semesterDiv.appendChild(semesterContent);
          container.appendChild(semesterDiv);
        });
      }

      // Build hierarchical tree from flat file list
      function buildTreeStructure(files) {
        const trees = {};
        const folderLookup = new Map(); // Store folder file objects by path
        const foldersByName = new Map(); // Store folders by name for fallback

        // First pass: build lookup table of all folders
        files.forEach((file) => {
          if (file.isFolder) {
            folderLookup.set(file.path, file);
            // Also store by name for fallback (in case of path mismatches)
            const folderKey = `${file.semester}_${file.batch}_${file.name}`;
            if (!foldersByName.has(folderKey)) {
              foldersByName.set(folderKey, []);
            }
            foldersByName.get(folderKey).push(file);
          }
        });

        files.forEach((file) => {
          const treeKey = `${file.semester}_${file.batch}`;
          if (!trees[treeKey]) {
            trees[treeKey] = {
              name: "root",
              children: {},
              files: [],
              isFolder: true,
            };
          }

          const pathParts = file.path.split("/");
          let currentNode = trees[treeKey];
          let currentPath = "";

          // Build path to the file, creating parent folders as needed
          for (let i = 0; i < pathParts.length - 1; i++) {
            const folderName = pathParts[i];
            currentPath = currentPath
              ? `${currentPath}/${folderName}`
              : folderName;

            if (!currentNode.children[folderName]) {
              // Look up the actual folder file object (multiple strategies)
              let folderFile = folderLookup.get(currentPath);

              // Fallback 1: Try to find by name in the same semester/batch
              if (!folderFile) {
                const folderKey = `${file.semester}_${file.batch}_${folderName}`;
                const matchingFolders = foldersByName.get(folderKey);
                if (matchingFolders && matchingFolders.length > 0) {
                  // Find the folder that best matches the current path
                  folderFile =
                    matchingFolders.find((f) => f.path.endsWith(currentPath)) ||
                    matchingFolders[0];
                }
              }

              currentNode.children[folderName] = {
                name: folderName,
                children: {},
                files: [],
                isFolder: true,
                hasMatchingContent: false,
                folderFile: folderFile, // Store the actual folder file for linking
                allMatchingFolders:
                  foldersByName.get(
                    `${file.semester}_${file.batch}_${folderName}`
                  ) || [], // Store all potential matches
              };
            }
            currentNode.children[folderName].hasMatchingContent = true;
            currentNode = currentNode.children[folderName];
          }

          // Add the file to the final folder
          currentNode.files.push(file);
        });

        return trees;
      }

      // Get batch label from tree structure
      function getBatchLabelFromTree(tree) {
        // Find first file in tree to get batch label
        function findFirstFile(node) {
          if (node.files && node.files.length > 0) {
            return node.files[0].batchLabel;
          }
          for (const child of Object.values(node.children)) {
            const result = findFirstFile(child);
            if (result) return result;
          }
          return null;
        }
        return findFirstFile(tree) || "Unknown Batch";
      }

      // Find folder file object to get its ID for linking
      function findFolderInFiles(folderName, folderNode) {
        // Return the stored folder file if available
        if (folderNode.folderFile && folderNode.folderFile.id) {
          return folderNode.folderFile;
        }

        // Fallback 1: Check all matching folders stored during tree building
        if (
          folderNode.allMatchingFolders &&
          folderNode.allMatchingFolders.length > 0
        ) {
          // Find the best matching folder (prefer exact path matches)
          const bestMatch = folderNode.allMatchingFolders.find(
            (folder) => folder.name === folderName && folder.id
          );
          if (bestMatch) {
            return bestMatch;
          }
          // If no exact match, return the first available folder with an ID
          const anyMatch = folderNode.allMatchingFolders.find(
            (folder) => folder.id
          );
          if (anyMatch) {
            return anyMatch;
          }
        }

        // Fallback 2: Look for folder in the files array
        const folderInFiles = folderNode.files.find(
          (file) => file.isFolder && file.name === folderName && file.id
        );

        if (folderInFiles) {
          return folderInFiles;
        }

        // Fallback 3: Look through all files in the node for any folder with an ID
        const anyFolderWithId = folderNode.files.find(
          (file) => file.isFolder && file.id
        );
        if (anyFolderWithId) {
          return anyFolderWithId;
        }

        // Fallback 4: Look in children for any folder file
        for (const [childName, childNode] of Object.entries(
          folderNode.children
        )) {
          if (childNode.folderFile && childNode.folderFile.id) {
            return childNode.folderFile;
          }
        }

        return null;
      }

      // Render tree node recursively
      function renderTreeNode(node, container, depth) {
        // Render folders first (sorted alphabetically)
        const sortedFolders = Object.entries(node.children).sort(([a], [b]) =>
          a.localeCompare(b)
        );

        sortedFolders.forEach(([folderName, folderNode]) => {
          if (folderNode.hasMatchingContent) {
            const folderDiv = document.createElement("div");
            folderDiv.className = "tree-file"; // Use same class as files
            folderDiv.style.paddingLeft = `${depth * 20}px`;

            // Create a clickable folder link
            const folderFile = findFolderInFiles(folderName, folderNode);
            let folderLink = "#";
            let clickHandler = "";

            if (folderFile && folderFile.id) {
              folderLink = `https://drive.google.com/drive/folders/${folderFile.id}`;
            } else {
              // If no folder ID found, try to find a parent folder or related file
              const relatedFile = folderNode.files.find((file) => file.id);
              if (relatedFile && relatedFile.webViewLink) {
                // Use the parent folder of this file as a fallback
                const parentId = relatedFile.webViewLink.match(
                  /\/folders\/([a-zA-Z0-9_-]+)/
                );
                if (parentId) {
                  folderLink = `https://drive.google.com/drive/folders/${parentId[1]}`;
                } else {
                  // If it's a file, try to navigate to its containing folder
                  folderLink = relatedFile.webViewLink;
                  clickHandler =
                    "onclick=\"alert('Opening related file since folder link is not available.'); return true;\"";
                }
              } else {
                // If no files or links found, show informative message
                clickHandler =
                  "onclick=\"alert('This folder contains matching files but direct folder access is not available. Try searching for specific files within this folder.'); return false;\"";
              }
            }

            folderDiv.innerHTML = `
              <div class="file-item">
                <a href="${folderLink}" target="_blank" class="result-link" ${clickHandler}>
                  <span class="file-icon">üìÅ</span>
                  <span class="file-name">${folderName}</span>
                </a>
              </div>
            `;
            container.appendChild(folderDiv);

            // Recursively render children
            renderTreeNode(folderNode, container, depth + 1);
          }
        });

        // Render files (sorted alphabetically)
        const sortedFiles = node.files.sort((a, b) =>
          a.name.localeCompare(b.name)
        );

        sortedFiles.forEach((file) => {
          const fileDiv = document.createElement("div");
          fileDiv.className = "tree-file";
          fileDiv.style.paddingLeft = `${depth * 20}px`;

          const icon = file.isFolder ? "üìÅ" : "üìÑ";
          const link = file.isFolder
            ? `https://drive.google.com/drive/folders/${file.id}`
            : file.webViewLink ||
              `https://drive.google.com/file/d/${file.id}/view`;

          fileDiv.innerHTML = `
            <div class="file-item">
              <a href="${link}" target="_blank" class="result-link">
                <span class="file-icon">${icon}</span>
                <span class="file-name">${file.name}</span>
              </a>
            </div>
          `;

          container.appendChild(fileDiv);
        });
      }

      // Toggle folder expansion for browse page
      async function toggleFolderExpansion(folderId, button) {
        const subfolderList = document.getElementById(`subfolder-${folderId}`);

        if (subfolderList.style.display === "none") {
          // Expand folder
          button.innerHTML = "‚ñ≤";
          button.title = "Collapse folder contents";
          subfolderList.style.display = "block";

          // Load folder contents if not already loaded - OPTIMIZED
          if (subfolderList.children.length === 0) {
            subfolderList.innerHTML = '<li class="loading">Loading...</li>';

            try {
              const response = await fetch(
                `https://www.googleapis.com/drive/v3/files?q='${folderId}'+in+parents+and+trashed=false&key=${DRIVE_API_KEY}&fields=files(id,name,mimeType,webViewLink)&pageSize=1000&orderBy=name`
              );

              if (!response.ok) {
                throw new Error(`API Error: ${response.status}`);
              }

              const data = await response.json();
              subfolderList.innerHTML = "";

              if (data.files && data.files.length > 0) {
                // Sort files alphabetically
                data.files.sort((a, b) => a.name.localeCompare(b.name));

                data.files.forEach((file) => {
                  const li = document.createElement("li");
                  li.className = "subfolder-item";

                  if (file.mimeType === "application/vnd.google-apps.folder") {
                    // Nested folder with its own dropdown
                    li.innerHTML = `
                      <div class="folder-item">
                        <a href="https://drive.google.com/drive/folders/${file.id}" target="_blank" class="folder-link">
                          üìÅ ${file.name}
                        </a>
                        <div class="folder-actions">
                          <button class="expand-btn" onclick="toggleFolderExpansion('${file.id}', this)" title="Expand folder contents">
                            ‚ñº
                          </button>
                        </div>
                      </div>
                      <ul class="subfolder-list" id="subfolder-${file.id}" style="display: none;"></ul>
                    `;
                  } else {
                    li.innerHTML = `
                      <a href="${
                        file.webViewLink ||
                        `https://drive.google.com/file/d/${file.id}/view`
                      }" target="_blank">
                        üìÑ ${file.name}
                      </a>
                    `;
                  }

                  subfolderList.appendChild(li);
                });
              } else {
                subfolderList.innerHTML =
                  '<li class="empty">No files found</li>';
              }
            } catch (error) {
              subfolderList.innerHTML = `<li class="error">Error loading: ${error.message}</li>`;
            }
          }
        } else {
          // Collapse folder
          button.innerHTML = "‚ñº";
          button.title = "Expand folder contents";
          subfolderList.style.display = "none";
        }
      }

      // Global filter function for deep search with improved responsiveness
      function globalFilter() {
        const searchTerm = document
          .getElementById("globalSearch")
          .value.toLowerCase()
          .trim();
        const semesterFilter = document.getElementById("semesterFilter").value;
        const batchFilter = document.getElementById("batchFilter").value;
        const stats = document.getElementById("resultsStats");

        // Show loading state during search if many files
        if (allFiles.length > 1000 && searchTerm) {
          stats.textContent = "Searching through files...";
        }

        if (!searchTerm && !semesterFilter && !batchFilter) {
          // Show empty state when no search terms
          displayResults([]);
          updateStats(0, allFiles.length);
          return;
        }

        // If search term is too short, provide feedback
        if (searchTerm && searchTerm.length < 2) {
          displayResults([]);
          stats.textContent = "Type at least 2 characters to search...";
          return;
        }

        let filtered = allFiles.filter((file) => {
          // Enhanced text search - includes file path and name
          const matchesSearch =
            !searchTerm ||
            file.name.toLowerCase().includes(searchTerm) ||
            file.path.toLowerCase().includes(searchTerm) ||
            file.batchLabel.toLowerCase().includes(searchTerm);

          // Semester filter
          const matchesSemester =
            !semesterFilter || file.semester === semesterFilter;

          // Batch filter
          const matchesBatch = !batchFilter || file.batch === batchFilter;

          return matchesSearch && matchesSemester && matchesBatch;
        });

        // Limit results to prevent overwhelming UI
        const maxResults = 200;
        let limitedResults = filtered;
        let resultMessage = "";

        if (filtered.length > maxResults) {
          limitedResults = filtered.slice(0, maxResults);
          resultMessage = ` (showing first ${maxResults} of ${filtered.length} matches)`;
        }

        // Remove duplicates when both folder and its contents match
        const uniqueResults = [];
        const processedPaths = new Set();

        // Sort by depth (shallow first) to prioritize parent folders
        limitedResults.sort((a, b) => a.depth - b.depth);

        limitedResults.forEach((file) => {
          const isParentAlreadyIncluded = Array.from(processedPaths).some(
            (path) => file.path.startsWith(path + "/") && file.path !== path
          );

          if (!isParentAlreadyIncluded) {
            uniqueResults.push(file);
            processedPaths.add(file.path);
          }
        });

        displayResults(uniqueResults);
        updateStats(uniqueResults.length, allFiles.length, resultMessage);
      }

      // Update results statistics
      function updateStats(shown, total, extraMessage = "") {
        const stats = document.getElementById("resultsStats");
        if (shown === 0 && total === 0) {
          stats.textContent = "No resources loaded yet.";
        } else if (shown === 0) {
          stats.textContent = `No matches found in ${total} total resources.`;
        } else {
          stats.textContent = `Showing ${shown} of ${total} resources${extraMessage}`;
        }
      }

      // Debounce function to prevent too many API calls
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Update the page initialization to be lightweight
      window.addEventListener("DOMContentLoaded", async () => {
        const stats = document.getElementById("resultsStats");

        // Run cache cleanup on startup
        cleanExpiredCache();

        // Get cache statistics
        const cacheStats = getCacheStats();

        // Check background preloader status
        // Background preloader disabled - was causing incomplete cache states
        // const backgroundStats = window.backgroundCachePreloader?.stats();

        if (cacheStats.entries > 0) {
          stats.innerHTML = `‚úÖ Ready! ${cacheStats.entries} folders available. Enter search terms to find resources. <a href="#" onclick="clearCacheAndReload()" style="color: #6b7280; font-size: 0.85em; text-decoration: none; margin-left: 8px;" title="Clear cache and reload fresh data">‚ü≥</a>`;
        } else {
          stats.textContent =
            "Ready to search! Enter terms above. First search will build cache and may take a moment.";
        }

        try {
          await loadDriveMapping();

          // Re-check cache stats after loading mapping
          const updatedCacheStats = getCacheStats();
          // Background preloader disabled - was causing incomplete cache states
          // const backgroundStats = window.backgroundCachePreloader?.stats();

          if (updatedCacheStats.entries > 0) {
            stats.innerHTML = `‚úÖ Ready! ${updatedCacheStats.entries} folders available. Enter search terms to find resources. <a href="#" onclick="clearCacheAndReload()" style="color: #6b7280; font-size: 0.85em; text-decoration: none; margin-left: 8px;" title="Clear cache and reload fresh data">‚ü≥</a>`;
          } else {
            stats.textContent =
              "‚úÖ Ready! Enter search terms or select filters to find resources. First search will build cache.";
          }
        } catch (error) {
          console.error("Failed to load drive mapping:", error);
          stats.textContent =
            "‚ö†Ô∏è Ready with basic setup. Some features may be limited.";
        }

        // Show empty state initially
        displayResults([]);

        // Log cache info to console for debugging (easter egg for developers!)
        console.log("üìã Cache Status:", cacheStats);
      });

      // === ACCORDION FUNCTIONALITY ===

      // Toggle semester collapse/expand
      function toggleSemesterCollapse(semester, button) {
        const content = document.getElementById(`semester-${semester}`);
        const icon = button.querySelector(".accordion-icon");

        if (content.style.display === "none") {
          // Expand
          content.style.display = "block";
          icon.textContent = "‚ñº";
          button.title = "Collapse semester";
        } else {
          // Collapse
          content.style.display = "none";
          icon.textContent = "‚ñ∂";
          button.title = "Expand semester";
        }
      }

      // Toggle batch collapse/expand
      function toggleBatchCollapse(semester, batch, button) {
        const content = document.getElementById(`batch-${semester}-${batch}`);
        const icon = button.querySelector(".accordion-icon");

        if (content.style.display === "none") {
          // Expand
          content.style.display = "block";
          icon.textContent = "‚ñº";
          button.title = "Collapse batch";
        } else {
          // Collapse
          content.style.display = "none";
          icon.textContent = "‚ñ∂";
          button.title = "Expand batch";
        }
      }

      // Utility function to collapse all semesters
      function collapseAllSemesters() {
        document.querySelectorAll(".semester-content").forEach((content) => {
          content.style.display = "none";
        });
        document
          .querySelectorAll(".semester-header .accordion-icon")
          .forEach((icon) => {
            icon.textContent = "‚ñ∂";
          });
      }

      // Utility function to expand all semesters AND batches
      function expandAllSemesters() {
        // First expand all semesters
        document.querySelectorAll(".semester-content").forEach((content) => {
          content.style.display = "block";
        });
        document
          .querySelectorAll(".semester-header .accordion-icon")
          .forEach((icon) => {
            icon.textContent = "‚ñº";
          });

        // Then expand all batches within those semesters
        document.querySelectorAll(".batch-content").forEach((content) => {
          content.style.display = "block";
        });
        document
          .querySelectorAll(".batch-header .accordion-icon")
          .forEach((icon) => {
            icon.textContent = "‚ñº";
          });
      }

      // Utility function to collapse all batches
      function collapseAllBatches() {
        document.querySelectorAll(".batch-content").forEach((content) => {
          content.style.display = "none";
        });
        document
          .querySelectorAll(".batch-header .accordion-icon")
          .forEach((icon) => {
            icon.textContent = "‚ñ∂";
          });
      }

      // Utility function to expand all batches
      function expandAllBatches() {
        document.querySelectorAll(".batch-content").forEach((content) => {
          content.style.display = "block";
        });
        document
          .querySelectorAll(".batch-header .accordion-icon")
          .forEach((icon) => {
            icon.textContent = "‚ñº";
          });
      }
    </script>

    <style>
      /* === ACCORDION STYLES === */
      .semester-header h2,
      .batch-header h3 {
        margin: 0;
        padding: 0;
      }

      .accordion-btn {
        width: 100%;
        background: none;
        border: none;
        text-align: left;
        padding: 12px 16px;
        cursor: pointer;
        display: flex;
        align-items: center;
        font-size: inherit;
        font-weight: inherit;
        color: inherit;
        border-radius: 8px;
        transition: all 0.2s ease;
      }

      .accordion-btn:hover {
        background: rgba(0, 0, 0, 0.05);
        transform: translateX(2px);
      }

      .accordion-btn:active {
        background: rgba(0, 0, 0, 0.1);
      }

      .accordion-icon {
        margin-right: 12px;
        font-size: 14px;
        color: #666;
        transition: transform 0.2s ease;
        display: inline-block;
        width: 18px;
        text-align: center;
      }

      .semester-header .accordion-btn {
        font-size: 1.5rem;
        font-weight: 600;
        color: #2196f3;
        padding: 8px 12px;
      }

      .batch-header .accordion-btn {
        font-size: 1.2rem;
        font-weight: 500;
        color: #333;
      }

      .semester-content,
      .batch-content {
        overflow: hidden;
        transition: all 0.3s ease;
      }

      /* Smooth animation for accordion */
      .semester-content[style*="display: none"],
      .batch-content[style*="display: none"] {
        opacity: 0;
        max-height: 0;
      }

      /* Results header and controls */
      .results-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
        flex-wrap: wrap;
        gap: 12px;
      }

      .accordion-controls {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .control-btn {
        background: #f0f9ff;
        border: 1px solid #0ea5e9;
        color: #0369a1;
        padding: 6px 12px;
        border-radius: 6px;
        font-size: 0.85em;
        cursor: pointer;
        transition: all 0.2s ease;
        white-space: nowrap;
      }

      .control-btn:hover {
        background: #0ea5e9;
        color: white;
        transform: translateY(-1px);
      }

      .control-btn:active {
        transform: translateY(0);
      }

      @media (max-width: 768px) {
        .results-header {
          flex-direction: column;
          align-items: flex-start;
        }

        .accordion-controls {
          width: 100%;
          justify-content: flex-start;
        }
      }

      .search-panel {
        background: #f8f9fa;
        padding: 20px;
        border-radius: 8px;
        margin-bottom: 24px;
      }

      .search-row {
        margin-bottom: 16px;
        display: flex;
        gap: 12px;
        align-items: center;
      }

      .search-row input {
        flex: 1;
        padding: 12px 16px;
        font-size: 1.1rem;
        border: 1px solid #ddd;
        border-radius: 6px;
      }

      #loadNextBtn {
        padding: 12px 16px;
        background-color: #2196f3;
        color: white;
        border: 1px solid #2196f3;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.9rem;
        white-space: nowrap;
        transition: all 0.3s ease;
      }

      #loadNextBtn:hover {
        background-color: #1976d2;
      }

      #loadNextBtn:disabled {
        background-color: #ccc;
        border-color: #ccc;
        cursor: not-allowed;
      }

      #searchLevelBtn {
        padding: 12px 16px;
        background-color: #4caf50;
        color: white;
        border: 1px solid #4caf50;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.9rem;
        white-space: nowrap;
      }

      #searchLevelBtn:hover {
        background-color: #45a049;
      }

      #searchLevelBtn:disabled {
        background-color: #ccc;
        border-color: #ccc;
        cursor: not-allowed;
      }

      .depth-indicator {
        font-size: 0.8rem;
        color: #666;
        margin-left: 8px;
        padding: 2px 6px;
        background-color: #f0f0f0;
        border-radius: 3px;
      }

      .filter-row {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
      }

      .filter-row select {
        padding: 8px 12px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 1rem;
        min-width: 150px;
      }

      .results-stats {
        margin-bottom: 16px;
        font-weight: 600;
        color: #666;
      }

      .semester-group {
        margin-bottom: 8px;
        padding-left: 16px;
      }

      .semester-group h2 {
        margin: 0 0 4px 0;
        color: #2196f3;
        display: block;
        width: 100%;
      }

      .batch-group {
        margin-bottom: 12px;
        background: #fff;
        border-radius: 6px;
        padding: 8px;
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.08);
      }

      .batch-group h3 {
        margin: 0 0 6px 0;
        color: #333;
        border-bottom: 1px solid #f0f0f0;
        padding-bottom: 4px;
        display: block;
        width: 100%;
      }

      .files-list {
        list-style: none;
        padding: 0;
        margin: 0;
      }

      .file-item {
        padding: 8px 0;
        border-bottom: 1px solid #f0f0f0;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .file-item:last-child {
        border-bottom: none;
      }

      .file-link {
        text-decoration: none;
        color: #2196f3;
        font-weight: 500;
      }

      .file-link:hover {
        text-decoration: underline;
      }

      .file-meta {
        font-size: 0.9rem;
        color: #666;
        font-style: italic;
      }

      .no-results {
        text-align: center;
        padding: 48px;
        color: #666;
        font-size: 1.1rem;
      }

      @media (max-width: 768px) {
        .filter-row {
          flex-direction: column;
        }

        .filter-row select {
          min-width: 100%;
        }

        .file-item {
          flex-direction: column;
          align-items: flex-start;
          gap: 4px;
        }
      }

      /* Tree structure styles for browse page */
      .batch-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 16px;
      }

      .batch-header h3 {
        margin: 0;
      }

      .root-folder-btn {
        background: none;
        color: #666;
        border: 1px solid #ddd;
        padding: 6px 8px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.9rem;
        transition: all 0.2s ease;
      }

      .root-folder-btn:hover {
        background: #f5f5f5;
        color: #2196f3;
        border-color: #2196f3;
      }

      .drive-list {
        list-style: none;
        padding-left: 0;
        margin: 0;
      }

      .drive-list-item {
        padding: 8px 0 8px 20px;
        border-bottom: 1px solid #eee;
        font-size: 1rem;
      }

      .folder-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .folder-link {
        flex-grow: 1;
        text-decoration: none;
        color: #333;
      }

      .folder-link:hover {
        color: #2196f3;
      }

      .folder-actions {
        display: flex;
        gap: 4px;
      }

      .expand-btn {
        background: none;
        border: 1px solid #ddd;
        padding: 4px 8px;
        cursor: pointer;
        border-radius: 4px;
        font-size: 12px;
      }

      .expand-btn:hover {
        background-color: #f0f0f0;
      }

      .subfolder-list {
        list-style: none;
        padding-left: 20px;
        margin: 8px 0;
        border-left: 2px solid #eee;
      }

      .subfolder-item {
        padding: 4px 0;
        font-size: 0.9rem;
      }

      .subfolder-item .folder-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin: 2px 0;
      }

      .subfolder-item .folder-actions {
        display: flex;
        gap: 2px;
      }

      .subfolder-item .expand-btn {
        padding: 2px 6px;
        font-size: 10px;
      }

      .subfolder-item a {
        text-decoration: none;
        color: #666;
      }

      .subfolder-item a:hover {
        color: #2196f3;
      }

      /* Nested subfolders with increased indentation */
      .subfolder-list .subfolder-list {
        padding-left: 15px;
        border-left: 1px solid #ddd;
      }

      .loading,
      .error,
      .empty {
        color: #999;
        font-style: italic;
        padding: 8px 0;
      }

      .error {
        color: #e74c3c;
      }

      /* Search results styling */
      .search-results {
        margin-top: 16px;
      }

      .search-result-item {
        padding: 8px 0;
        border-bottom: 1px solid #f0f0f0;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .result-link {
        text-decoration: none;
        color: #333;
        font-weight: 500;
      }

      .result-link:hover {
        color: #2196f3;
      }

      .file-path {
        font-size: 0.85rem;
        color: #666;
        font-style: italic;
      }

      .no-results {
        text-align: center;
        padding: 40px 20px;
        color: #666;
        font-style: italic;
      }

      /* Tree structure styles */
      .tree-results {
        margin-top: 16px;
      }

      .tree-file {
        margin: 2px 0;
      }

      .file-item {
        display: flex;
        align-items: center;
        padding: 6px 8px;
        border-radius: 4px;
        transition: background-color 0.2s ease;
      }

      .file-item:hover {
        background: #f1f3f4;
      }

      .file-icon {
        margin-right: 8px;
        font-size: 16px;
      }

      .file-name {
        color: #333;
        text-decoration: none;
        font-weight: 500;
      }

      .result-link {
        text-decoration: none;
        color: inherit;
        display: flex;
        align-items: center;
        width: 100%;
      }

      .result-link:hover .file-name {
        color: #2196f3;
        text-decoration: underline;
      }

      /* Tree indentation lines */
      .tree-folder:not(:first-child)::before,
      .tree-file:not(:first-child)::before {
        content: "";
        position: absolute;
        left: 0;
        width: 1px;
        background: #dee2e6;
        height: 100%;
      }
    </style>
  </body>
</html>
